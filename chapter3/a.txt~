时刻记住一个事实,那就是所有的模块都有能力来执行代码。最高级别的 Python 语句--
也就是说, 那些没有缩进的代码行在模块被导入时就会执行, 不管是不是真的需要执行。由
于有这样一个“特性”,比较安全的写代码的方式就是除了那些真正需要执行的代码以外, 几
乎所有的功能代码都在函数当中。再说一遍, 通常只有主程序模块中有大量的顶级可执行代码,
所有其它被导入的模块只应该有很少的顶级执行代码,所有的功能代码都应该封装在函数或类
当中。


核心笔记:__name__ 指示模块应如何被加载
由于主程序代码无论模块是被导入还是被直接执行都会运行, 我们必须知道模块如何决定
运行方向。一个应用程序可能需要导入另一个应用程序的一个模块,以便重用一些有用的代码
(否则就只能用拷贝粘贴那种非面向对象的愚蠢手段)。这种情况下,你只想访问那些位于其
它应用程序中的代码,而不是想运行那个应用程序。因此一个问题出现了,“Python 是否有
一种方法能在运行时检测该模块是被导入还是被直接执行呢?” 答案就是......(鼓声雷
动).....没错! __name__ 系统变量就是正确答案。
如果模块是被导入, __name__ 的值为模块名字
如果模块是被直接执行, __name__ 的值为 '__main__'

核心技巧:使用局部变量替换模块变量
类似 os.linesep 这样的名字需要解释器做两次查询:
(1)查找 os 以确认它是一个模块,
(2)在这个模块中查找 linesep 变量。因为模块也是全局变量, 我们多消耗了系统资源。如
果你在一个函数中类似这样频繁使用一个属性,我们建议你为该属性取一个本地变量别名。 变
量查找速度将会快很多--在查找全局变量之前, 总是先查找本地变量。 这也是一个让你的
程序跑的更快的技巧: 将经常用到的模块属性替换为一个本地引用。代码跑得更快,而也不用
老是敲那么长的变量名了。在我们的代码片段中,并没有定义函数,所以不能给你定义本地别
名的示例。不过我们有一个全局别名,至少也减少了一次名字查询s

