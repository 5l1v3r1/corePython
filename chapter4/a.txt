核心笔记:布尔值
所有标准对象均可用于布尔测试,同类型的对象之间可以比较大小。每个对象天生具有布
尔 True 或 False 值。空对象、值为零的任何数字或者 Null 对象 None 的布尔值都是 False。
下列对象的布尔值是 False。
z None
z False (布尔类型)
z 所有的值为零的数:
z 0 (整型)
z (浮点型)
z 0L (长整型)
z 0.0+0.0j (复数)
z "" (空字符串)
z [] (空列表)
z () (空元组)
z {} (空字典)
值不是上面列出来的任何值的对象的布尔值都是 True,例如 non-empty、 non-zero 等等。
用户创建的类实例如果定义了 nonzero(__nonzero__())或 length(__len__())且值为 0,那
么它们的布尔值就是 False。

核心提示:实践
在上面的例子中,您会注意到我们使用的是浮点数而不是整数。为什么这样?整数对象和
字符串对象是不可变对象,所以 Python 会很高效的缓存它们。这会造成我们认为 Python 应该
创建新对象时,它却没有创建新对象的假象。看下面的例子:
>>> a = 1
>>> id(a)
8402824
>>> b = 1
>>> id(b)
8402824
>>>
>>> c = 1.0
>>> id(c)
8651220
>>> d = 1.0
>>> id(d)
8651204
在上面的例子中,a 和 b 指向了相同的整数对象,但是 c 和 d 并没有指向相同的浮点数
对象。如果我们是纯粹主义者,我们会希望 a 与 b 能和 c 与 d 一样,因为我们本意就是为
了创建两个整数对象,而不是像 b = a 这样的结果。

核心笔记:为什么我们有了 repr()还需要``?
在 Python 学习过程中,你偶尔会遇到某个运算符和某个函数是做同样一件事情。之所以如
此是因为某些场合函数会比运算符更适合使用。举个例子, 当处理类似函数这样的可执行对象
或根据不同的数据项调用不同的函数处理时,函数就比运算符用起来方便。另一个例子就是双
星号(**)乘方运算和 pow()内建函数,x ** y 和 pow(x,y) 执行的都是 x 的 y 次方。
鼓励用函数

由于 Python 奉行简单但是比较慢的方式,所以我们必须这么做,看一眼我们原来的条件
表达式:
if type(num) == type(0)...
减少函数调用的次数
如果我们仔细研究一下我们的代码,会看到我们调用了两次 type()。要知道每次调用函数
都会付出性能代价, 如果我们能减少函数的调用次数, 就会提高程序的性能。
利用在本章我们前面提到的 types 模块, 我们还有另一种比较对象类型的方法,那就是
将检测得到的类型与一个已知类型进行比较。如果这样, 我们就可以直接使用 type 对象而不
用每次计算出这个对象来。那么我们现在修改一下代码,改为只调用一次 type()函数:
>>> import types
>>> if type(num) == types.IntType..
如果它们是同一个对象, 我们为什么还要浪费时间去获得并比较它们的值呢(我们已经知
道它们是相同的了!)? 所以比较对象本身是一个更好地方案.下面是改进后的代码:
if type(num) is types.IntType... # or type(0)
减少查询次数：
这是一个对前一个例子较小的改进,如果你的程序像我们的例子中做很多次比较的话,程
序的性能就会有一些差异。为了得到整数的对象类型,解释器不得不首先查找 types 这个模块
的名字,然后在该模块的字典中查找 IntType。通过使用 from-import,你可以减少一次查询:
from types import IntType
if type(num) is IntType...

if isinstance(num, int)...
在判断对象类型时也使用 isinstance() 已经被广为接受, 我们上面的 typechk.py 脚本
最终与改成了使用 isinstance() 函数。值得一提的是, isinstance()接受一个类型对象的元
组做为参数, 这样我们就不必像使用 type()时那样写一堆 if-elif-else 判断了。

